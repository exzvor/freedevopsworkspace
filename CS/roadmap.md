# Общие инженерные компетенции

Прежде чем приступать к изучению технологий DevOps, стоит уделить большое внимание общим инженерным навыкам. Эти знания
обеспечат крепкий фундамент и понимание того, как построена та или иная технология. Общие инженерные компетенции включают в себя:
1. **Общие понятия:** основа того, как именно работают компьютеры и программное обеспечение. От архитектуры компьютера до понятия как работают сети. Эти знания помогают DevOps-специалистам лучше понимать, как развертывать, масштабировать и управлять сложными системами.
2. **Программирование и скриптовые языки:** DevOps часто требует написания или изменения скриптов и кода. Базовые навыки программирования и понимание алгоритмов, будут здесь невероятно полезными.
3. **Базы данных:** Понимание структуры и функционирования баз данных является важным элементом для эффективного управления данными и ресурсами, что часто встречается в задачах DevOps.
4. **Теория систем:** DevOps-специалистам необходимо управлять и обслуживать различные системы. Понимание принципов работы операционных систем, компьютерных сетей и облачных вычислений - это ключевая составляющая, которая будет полезна в DevOps.
5. **TroubleShooting:** навыки, необходимые для решения сложных и технических проблем, которые часто возникают в рабочем процессе DevOps.

DevOps-инженер прежде всего технический специалист, который понимает как работают все процессы. Многие крупные компании готовы нанимать специалистов, 
которые обладают отличными общими инженерными компетенциями. В таком случае возможно попасть на хорошую вакансию даже без знания других технических инструментов. Так как считается, что такой инженер сможет быстро освоить и другие технологии.

Полностью обхватить все инженерные компетенции на этой площадке вряд ли получится. Поэтому предлагаю пройтись по перечню основных тем и 
более углубленно их изучить уже самостоятельно с дополнительной литературой. Список вопросов будет в конце фрагмента.

### Список тем:

<details>
<summary>Основные компоненты компьютера</summary><br>

- **Центральный процессор (CPU)**: Основной вычислительный компонент, выполняющий инструкции программы и управляющий работой остальных компонентов.

- **Оперативная память (RAM)**: Временное хранилище данных и программ, с которыми процессор взаимодействует в режиме реального времени.

- **Жесткий диск (HDD) или твердотельный накопитель (SSD)**: Устройство для долгосрочного хранения данных, операционной системы и программ.

- **Материнская плата**: Основная плата, на которой установлены и связаны между собой все остальные компоненты, включая ЦП, ОЗУ и различные порты.

- **Графический процессор (GPU)**: Отвечает за обработку графики, 3D-визуализацию, а также вычисления в областях, требующих большой вычислительной мощности.

- **Звуковая карта**: Обеспечивает воспроизведение и запись звука, а также поддерживает аудиоинтерфейсы.

- **Сетевая карта**: Позволяет компьютеру подключаться к сетям, включая интернет, через проводное или беспроводное соединение.

- **Устройства ввода-вывода**: Разнообразные разъемы для подключения устройств ввода (клавиатура, мышь) и вывода (монитор, принтер и т.д.).

- **Периферийные устройства (PCI)**: Внешние устройства, такие как принтеры, сканеры, внешние жесткие диски и др.
</details>

<details>
<summary>Операционная система</summary><br>

Операционная система — это системное программное обеспечение, которое предоставляет интерфейс для взаимодействия пользовательских приложений с оборудованием компьютера. 
Она управляет и координирует деятельность оборудования и софта, выступая между ними в качестве посредника.
Операционная система отвечает за разнообразный спектр функций, включая:

1. **Управление процессами**: ОС организует различные процессы и программы на компьютере, обеспечивая их аккуратное выполнение.
2. **Управление памятью**: ОС контролирует распределение и использование оперативной и долговременной памяти компьютера.
3. **Планирование задач**: ОС определяет, как и когда процессы должны быть выполнены.
4. **Взаимодействие с оборудованием**: ОС обеспечивает доступ к аппаратным ресурсам компьютера, таким как дисковое пространство, принтеры или другие периферийные устройства.
5. **Предоставление интерфейса для пользователя**: ОС предлагает графический пользовательский интерфейс (GUI), с которым пользователь может взаимодействовать, чтобы выполнить различные задачи.
6. **Управление файлами и файловыми системами**: ОС управляет файлами и файловыми системами, обеспечивая доступ, хранение, поиск и манипуляцию данными.
7. **Управление безопасностью**: ОС предлагает функции защиты и безопасности, ограничивая доступ к ресурсам, отслеживая активность и защищая от вирусов или другого вредоносного ПО.

Основные ОС: `Microsoft Windows`, `Mac OS`, `Linux` и `Android`.
</details>

<details>
<summary>Ядро ОС (Kernel)</summary><br>

**Ядро** — это центральная часть операционной системы. Оно обеспечивает низкоуровневое взаимодействие 
программного обеспечения с аппаратными ресурсами компьютера, а также управляет системными ресурсами, 
например, контролирует выполнение процессов, управляет памятью, взаимодействует с устройствами 
ввода-вывода и обеспечивает сетевые функции.

Ядро предназначено для:

1. **Управление процессами и потоками**: Ядро принимает решения о том, когда и как долго процессы и потоки должны выполняться. Оно также обрабатывает создание, завершение и синхронизацию процессов и потоков.
2. **Управление памятью**: Ядро управляет распределением и освобождением памяти, а также обеспечивает защиту памяти и механизмы виртуальной памяти.
3. **Обработка ввода / вывода и управление устройствами**: Ядро обеспечивает взаимодействие с устройствами ввода/вывода, такими как жесткий диск, клавиатура, мышь и принтер, управляет драйверами устройств и распределяет ресурсы между устройствами.
4. **Управление системными вызовами**: Ядро предоставляет программам интерфейс для доступа к аппаратным и системным ресурсам через системные вызовы.
5. **Обеспечение безопасности**: Ядро предоставляет функции безопасности, такие как контроль доступа, изоляция процессов и управление пользователями и группами пользователей.
Ядро играет ключевую роль в работе операционной системы, обеспечивая стабильное и безопасное функционирование системы в целом.
</details>

<details>
<summary>Загрузка ОС</summary><br>

**Загрузка операционной системы**, или процесс загрузки (booting), это процесс, при котором компьютер
собирает информацию из различных системных компонентов и загружает операционную систему в память
для выполнения. Вот типичная последовательность шагов, происходящих при старте компьютера:

1. **Пусковой тест при включении (POST)**: Когда компьютер впервые включается, он выполняет `POST` (Power-On Self Test). В этом тесте BIOS (базовая система ввода-вывода) проверяет аппаратное обеспечение компьютера, чтобы убедиться, что все работает корректно.
2. **Стадия загрузки в BIOS/UEFI**: После `POST`, BIOS или его современный эквивалент `UEFI` запускается и ищет загрузочное устройство (обычно это жесткий диск, но это также может быть CD/DVD-диск, USB-устройство или сетевое устройство).
3. **Загрузчик Bootloader**: `BIOS` или `UEFI` затем запускают bootloader с загрузочного устройства. Bootloader, такой как GRUB для Linux или Boot Manager для Windows, загружает основное ядро операционной системы.
4. **Загрузка ядра ОС**: Ядро ОС, при загрузке, выполняет инициализацию системных ресурсов, загружает драйверы устройств, инициализирует процессы и запускает менеджер системы или супервайзер (например, systemd на Linux, или Service Control Manager на Windows).
5. **Запуск сеанса пользователя**: После того, как все системные службы были загружены, следующий шаг — это запуск пользовательского интерфейса, такого как графический интерфейс (GUI) или командная строка (CLI). В случае GUI, этот процесс обычно заключается в запуске программы входа в систему, которая ждет, пока пользователь введет имя пользователя и пароль.
6. **Запуск пользовательских программ**: После успешного входа в систему, запускаются пользовательские программы и службы, включая всё, что указано в настройках автозагрузки.

После всех этих шагов компьютер готов к работе, и пользователь может начинать использовать систему.
</details>

<details>
<summary>Архитектура ОС</summary><br>

**Архитектура операционной системы** описывает организацию компонентов, структуру и взаимодействие между ними внутри операционной системы. Существует несколько распространенных архитектурных подходов, на которых строятся операционные системы. Ниже представлен обзор некоторых типов архитектур операционных систем:

- **Монолитная архитектура (Monolithic Architecture)**:
В монолитной архитектуре все компоненты операционной системы, такие как файловая система, планировщик задач, драйверы устройств и т.д., находятся в одной большой программе (ядре операционной системы). Взаимодействие между компонентами обеспечивается вызовами функций. Это простой подход, но может привести к сложностям при обновлениях и модификациях системы.

- **Микроядерная архитектура (Microkernel Architecture)**:
В этой архитектуре ядро операционной системы содержит только основные функции, такие как планирование задач, управление памятью и межпроцессное взаимодействие. Остальные сервисы, такие как файловые системы и драйверы устройств, работают как пользовательские процессы. Это уменьшает сложность ядра и облегчает расширение и обновление системы, но может привести к ухудшению производительности из-за повышенных накладных расходов на межпроцессное взаимодействие.

- **Модульная архитектура (Modular Architecture)**:
Это комбинация монолитной и микроядерной архитектур. Операционная система разделяется на модули, каждый из которых отвечает за определенный аспект, например, файловую систему, сетевые службы и др. Эти модули могут работать в контексте ядра или как пользовательские процессы.

- **Виртуальная машина (Virtual Machine) или Гипервизор**:
В этом случае операционная система работает на уровне виртуальной машины, которая может поддерживать выполнение нескольких операционных систем на одном физическом компьютере. Этот подход позволяет изолировать разные системы и обеспечивает высокий уровень гибкости, но может потребовать больше вычислительных ресурсов.

Реальные операционные системы могут использовать комбинации этих подходов и включать другие дополнительные аспекты, такие как безопасность, многозадачность и управление ресурсами.
</details>

<details>
<summary>Оболочка (Shell)</summary><br>

**Оболочка (shell)** в операционных системах — это программный интерфейс, который предоставляет пользователям доступ к основным сервисам операционной системы.

Оболочка может быть графической (GUI), такой как Windows Shell в операционной системе Windows или рабочий стол GNOME в Linux. Однако, термин обычно используется в контексте командной строки или текстового интерфейса (CLI), такого как Bash (Bourne Again Shell) в Unix или Linux, или командный интерпретатор (cmd) в Windows.

Оболочка позволяет пользователю осуществлять различные операции, вроде управления файлами и директориями, запуска программ, управления процессами, и даже кодирования скриптов для автоматизации задач. Все это выполнимо при помощи специальных команд, вводимых в текстовый интерфейс.

Оболочка служит важным инструментом коммуникации между пользователем и операционной системой.
</details>

<details>
<summary>Переменные окружения</summary><br>

**Переменные окружения** — это набор пар "ключ-значение", которые хранят информацию о системном окружении. 
Они используются операционной системой для передачи конфигурационной информации приложениям. 
Эта информация часто включает пути к системным и пользовательским файлам, настройки сети и другие сведения, 
которые могут меняться в зависимости от системы.

Примерами переменных окружения могут быть:

- `PATH`: содержит список каталогов, в которых операционная система будет искать исполняемые файлы.
- `HOME`: указывает домашний каталог текущего пользователя в Unix-системах или Windows соответственно.
- `LANG`: определяет язык, использующийся в программах пользовательской оболочки.
Устанавливая переменные окружения, мы можем контролировать поведение программ, не изменяя их исходный код. 
Кроме системных переменных, пользователи и приложения могут создавать свои собственные переменные окружения.

Простой пример использования переменной окружения — это задание параметра `DEBUG=true` для отладки приложения без изменения его исходного кода.

Все операционные системы предлагают средства для просмотра, установки и изменения переменных окружения.
</details>

<details>
<summary>Режимы привилегий</summary><br>

**Режим ядра (Kernel Mode) и режим пользователя (User Mode) - это уровни привилегий, в которых работает центральный процессор компьютера при выполнении программ.**

1. **Режим ядра (Kernel Mode)**:
В этом режиме операционная система имеет полный доступ ко всем ресурсам и привилегиям компьютера.
Операционная система выполняет критические задачи, такие как управление памятью, планирование задач, обработка аппаратных прерываний и взаимодействие с аппаратными устройствами.
Инструкции, выполняемые в режиме ядра, обычно являются привилегированными, то есть они могут выполнять операции, которые не доступны в режиме пользователя.
2. **Режим пользователя (User Mode)**:
В этом режиме программы, выполняющиеся на компьютере, работают с ограниченными привилегиями и доступом к ресурсам.
Программы в режиме пользователя обычно не имеют прямого доступа к аппаратным ресурсам и выполнению критических операций.
Операции, выполняемые в режиме пользователя, должны быть разрешены операционной системой, которая контролирует доступ к ресурсам и обеспечивает безопасность.


**Зачем нужны режимы привилегий:**
- Режимы привилегий важны для обеспечения безопасности, стабильности и контроля в компьютерных системах. Они позволяют операционной системе разграничивать доступ к ресурсам и управлять выполнением задач. Вот некоторые основные причины:

- Изоляция и защита: Режимы позволяют изолировать различные программы и процессы друг от друга. Это предотвращает вмешательство и воздействие одной программы на другую.

- Безопасность: Режим ядра обеспечивает контроль над выполнением операций с высокими привилегиями. Это позволяет избегать незаконных или потенциально опасных действий.

- Стабильность: Режим ядра контролирует аппаратные ресурсы и обеспечивает выполнение критических задач, таких как планирование задач и управление памятью.

- Контроль доступа: Режимы позволяют операционной системе управлять доступом программ к ресурсам, таким как память, файлы и аппаратные устройства.

- Предотвращение конфликтов: Режимы помогают предотвращать конфликты и состязания между программами за ресурсы.

- Режимы ядра и пользователя играют важную роль в обеспечении безопасности, эффективности и стабильности работы компьютерных систем.
</details>

<details>
<summary>POSIX</summary><br>

**POSIX (Portable Operating System Interface)** — это набор стандартов, разработанных Институтом инженеров электротехники 
и электроники (IEEE), чтобы обеспечить совместимость между операционными системами.

`POSIX` определяет интерфейс операционной системы, который должен использоваться для обеспечения портабельности 
программного обеспечения. Это включает в себя аспекты, такие как работа с файлами и каталогами, управление процессами
и потоками, а также обработка сигналов.

Поскольку большинство UNIX-подобных операционных систем (`Linux`, `MacOS`, `FreeBSD`, `OpenBSD`, `NetBSD`, `Solaris`), следуют стандартам POSIX, программное
обеспечение, написанное в соответствии с этими стандартами, может быть запущено на любой из этих систем без 
значительной модификации кода.

Важно отметить, что `POSIX` — это не операционная система, а набор стандартов, которые помогают разработчикам 
программного обеспечения создавать кросс-платформенные программы.
</details>

<details>
<summary>Системные вызовы</summary><br>

**Системные вызовы (system calls)** — это интерфейс (функции) между пространством пользователя и пространством ядра в 
операционных системах. Эти функции, предоставляются ядром операционной системы. Они позволяют программам
в пространстве пользователя взаимодействовать с системными ресурсами или осуществлять операции, которые 
обычно доступны только операционной системе.

Основные системные вызовы включают следующие:

- **Управление процессами**: Создание, завершение, ожидание и планирование процессов. В библиотеке `POSIX` эти функции обычно называются `fork(), exit(), wait(), exec()`, и т.д.

- **Управление памятью**: Выделение, освобождение памяти, а также защита областей памяти. Примеры таких системных вызовов — `brk(), mmap(), mprotect(), munmap()`.

- **Управление файлами**: Открытие, чтение, запись, закрытие файлов, а также операции с каталогами. Примеры таких системных вызовов — `open(), read(), write(), close(), mkdir(), rmdir(), stat(), fstat(),lstat()` и другие.

- **Управление устройствами**: Контроль над вводом-выводом и другими устройствами. Примеры системных вызовов включают `ioctl(), read(), write()`.

- **Коммуникация между процессами (IPC)**: Семафоры, сообщения, разделяемая память и др. Примеры тут могут быть `semop(), msgsnd(), msgrcv(), shmget()` и т.д.

- **Сетевые функции**: Сетевые операции, включая сокеты. Примеры системных вызовов включают `socket(), bind(), connect(), listen(), accept(), send(), receive()`.

Системные вызовы служат мостом между программами пользователя и возможностями ядра операционной системы, позволяя при этом поддерживать необходимый контроль и безопасность.
</details>

<details>
<summary>Мультиплексирование</summary><br>

**Мультиплексирование** - распределение ресурсов в ОС двумя различными способами: во времени и в пространстве.
Когда ресурс разделяется во времени, различные программы или пользователи используют его по
очереди: сначала ресурс получают в пользование одни, потом другие и т.д. Другим видом разделения ресурсов является пространственное разделение. Вместо
поочередной работы каждый клиент получает какую-то часть разделяемого ресурса.
</details>

<details>
<summary>Потоки и процессы</summary><br>

**Процесс** — это экземпляр программы, которая выполняется на компьютере. Каждый процесс имеет свою собственную область памяти и свое состояние. Он также содержит информацию о своем выполнении, включая значение счетчика команд и значения регистров. Процессы могут взаимодействовать друг с другом через системные вызовы для межпроцессного взаимодействия (IPC).

**Поток**, с другой стороны, иногда называемый "легким" процессом, — это отдельная последовательность выполнения в рамках процесса. Потоки в одном процессе разделяют ту же область памяти и ресурсы, что и сам процесс, что позволяет потокам эффективно обмениваться данными друг с другом. Индивидуальный поток имеет собственный счетчик команд, стек и состояние регистров.

Вот несколько ключевых отличий между процессами и потоками:

- **Независимость**: Процессы являются боле независимыми друг от друга по сравнению с потоками. Если один процесс падает или зависает, это обычно не влияет на другие процессы. С другой стороны, если один поток в процессе падает, это обычно приводит к падению всего процесса.

- **Расходы на переключение**: Переключение между потоками в пределах одного процесса обычно менее ресурсоемко, чем переключение между процессами, поскольку потоки разделяют общее адресное пространство.

- **Общение и синхронизация**: Поскольку потоки в одном процессе разделяют общую память, взаимодействие и синхронизация между ними обычно проще, чем между процессами. Тем не менее, это также может привести к сложностям, таким как состояния гонки, если не обеспечивается должная синхронизация.

- **Ресурсы**: Каждый процесс имеет свой собственный набор ресурсов, в то время как все потоки в пределах одного процесса разделяют ресурсы.

Оба этих понятия играют ключевую роль в многозадачности, позволяя операционной системе максимально эффективно использовать процессорное время и ресурсы.
</details>

<details>
<summary>Цикл жизни процессов</summary><br>

**Цикл жизни процесса** — это последовательность состояний, через которые проходит процесс при его создании, выполнении, завершении и управлении операционной системой. Обычно цикл жизни процесса включает следующие этапы:

- **Создание (Creation)**:
Процесс создается при необходимости выполнения определенной задачи. В этом этапе операционная система выделяет ресурсы, такие как память, инициализирует регистры и данные процесса. Процесс также получает уникальный идентификатор (PID).

- **Готовность (Ready)**:
После создания процесс переходит в состояние готовности. В этом состоянии процесс ожидает выделения процессорного времени, чтобы начать выполнение. На этом этапе он находится в очереди процессов, готовых к выполнению.

- **Выполнение (Running)**:
Когда процесс получает процессорное время, он переходит в состояние выполнения. Процессор выполняет инструкции этого процесса. В многозадачных системах процессы могут переключаться между состояниями выполнения и готовности.

- **Ожидание (Waiting или Blocked)**:
Если процесс ожидает выполнения какого-либо события (например, ввода-вывода), он переходит в состояние ожидания. В этом состоянии процесс не выполняется, и операционная система может выделить процессорное время другому процессу.

- **Завершение (Termination)**:
Процесс завершается, когда он выполнил свою задачу или был принудительно завершен операционной системой. На этом этапе освобождаются ресурсы, выделенные процессу, и его запись удаляется из списка активных процессов.

- **Зомби (Zombie)**:
Процесс переходит в состояние зомби, когда он завершается, но его родительский процесс ещё не запросил 
статус завершения этого процесса. В этот момент операционная система сохраняет некоторую информацию о 
завершенном процессе, чтобы родительский процесс мог в дальнейшем запросить этот статус.

Обратите внимание, что процессы могут переходить между этими состояниями в зависимости от внешних событий и алгоритмов планирования операционной системы. Цикл жизни процесса демонстрирует, как операционная система управляет процессами и ресурсами для обеспечения эффективного выполнения задач.
</details>

<details>
<summary>Многопоточное выполнение программ</summary><br>

**Многопоточное выполнение программ** — это метод, при котором одна программа выполняется как несколько 
параллельных процессов или "потоков".

Потоки обрабатываются независимо друг от друга, каждый имеет собственные регистры процессора, 
собственное состояние и собственный область стека в памяти. Однако все потоки одного процесса 
разделяют общее адресное пространство, что позволяет им обмениваться данными и взаимодействовать
друг с другом намного быстрее, чем отдельные процессы.

Многопоточность используется во многих сценариях, включая следующие:

- **Обработка ввода/вывода и вычисления**: в программе можно использовать один поток для чтения данных или ожидания пользовательского ввода, в то время как другой поток может выполнять вычисления или обрабатывать данные.

- **Параллельное выполнение**: если у вас есть многоядерный процессор или несколько процессоров, многопоточное выполнение позволяет программе использовать все ядра одновременно, повышая производительность.

- **Обработка нескольких запросов**: в серверных приложениях, например, веб-серверах, каждый входящий запрос может быть обработан в отдельном потоке, обеспечивая эффективное распределение нагрузки.

Однако многопоточность также приносит свои проблемы, такие как сложности синхронизации потоков. Кроме того, из-за разделяемого состояния потоков возможно появление состояния гонки (race condition), когда два или более потока пытаются изменить общую переменную одновременно.
</details>

<details>
<summary>Блокировки и мьютексы</summary><br>

**Блокировки (locks)** — это механизмы, используемые в системах многозадачного исполнения (или 
многопоточности) для координации доступа к общим ресурсам или критическим секциям кода. Они служат для предотвращения 
гонки данных (race condition), что может произойти, когда два или более процесса или потока пытаются одновременно обратиться к 
определенным данным или ресурсу, что может привести к неверным результатам.

В основном, блокировки используются для гарантии того, что только один поток выполнит определенную критическую секцию 
кода в данное время.

**Мьютекс (Mutex)**, т.е. взаимное исключение — это особый тип блокировки, который предотвращает одновременное 
выполнение двух и более потоков или процессов в определенной критической секции. Когда поток входит в критическую 
секцию, он "захватывает" мьютекс — другие потоки, пытающиеся войти в этот участок кода, будут заблокированы до 
тех пор, пока первый поток не "освободит" мьютекс.

Мьютекс способствует целостности данных, исключая "гонку" двух и больше потоков за общим ресурсом и 
обеспечивает взаимное исключение в доступе к общим ресурсам и критическим секциям кода.
</details>

<details>
<summary>Deadlocks</summary><br>

В контексте параллельной и многопоточной обработки **deadlock** — это состояние, при котором два или более 
процессов или потоков бесконечно ждут друг друга для освобождения ресурса, что приводит к взаимной блокировке 
и остановке выполнения всех вовлеченных процессов.

Тупики обычно возникают, когда несколько потоков, придерживаясь следующих четырех условий, запрашивают одни 
и те же ресурсы:

1. **Взаимное исключение**: Каждый ресурс либо в данный момент занят одним потоком, либо доступен.
2. **Удержание и ожидание**: Поток уже удерживает как минимум один ресурс и ожидает другой ресурс, который в данный момент удерживается другим потоком.
3. **Нет вытеснения**: Ресурсы не могут быть изъяты принудительно. Они должны быть освобождены добровольно.
4. **Циклическое ожидание**: Существует цикл ожидания, где каждый из потоков в цикле ожидает ресурс, который удерживает следующий поток в цикле.

Чтобы предотвратить deadlocks, можно попытаться устранить одно или несколько из этих условий, например:
- Ввести стратегию разделения ресурсов, где каждый поток должен запрашивать и получать все его ресурсы за один раз.
- Внедрить принцип отказа и отката. Если операция, такая как запрос ресурса, не может быть выполнена из-за ошибки или проблемы 
(например, ресурс уже захвачен другим потоком), поток "откажется" от выполнения операции и к раннему состоянию. 
Процесс или поток затем будет "ждать" некоторое время, прежде чем попытаться выполнить операцию снова.
- Установить порядок захвата ресурсов. Процессы требуют ресурсы в строго определенном порядке.
- 
Чтобы управлять уже возникшими deadlocks, можно применить один из следующих подходов:
- Пропустить процесс или поток, чтобы освободить заблокированные ресурсы.
- Откатить процесс или поток до точки, которая позволит ему продолжать выполнение и освободить ресурсы.
</details>

<details>
<summary>Память</summary><br>

**Память** в компьютере имеет иерархию, которая определяется скоростью, емкостью и стоимостью компонентов. 
Основные виды памяти включают:

- **Регистры процессора**: Это наиболее быстрый тип памяти в компьютере. Регистры процессора хранят данные, непосредственно участвующие в текущих вычислениях.

- **Кэш-память**: Кэш-память — это небольшой объем высокоскоростной памяти, расположенной непосредственно на процессоре или рядом с ним. Уровни кэш-памяти (L1, L2, L3) отличаются по размеру и скорости доступа.

- **Оперативная память (RAM)**: RAM — это основное рабочее пространство компьютера, где он хранит данные и программы, над которыми в данный момент осуществляются операции. Она значительно больше по объему, чем кэш или регистры, но и немного медленнее по скорости.

- **Память виртуальная**: Когда оперативной памяти (RAM) не хватает для работы всех процессов, операционная система может использовать часть жесткого диска в качестве памяти. Это называется виртуальной памятью. Она значительно медленнее по сравнению с оперативной памятью.

- **Постоянная память (ROM, SSD, HDD)**: Это память компьютера, которая сохраняет информацию даже после выключения питания. Она используется для хранения операционной системы, приложений и личных файлов пользователя. ROM (Read-Only Memory) используется для хранения фиксированной информации, которую требуется загрузить при включении компьютера. SSD (Solid State Drives) и HDD (Hard Disk Drives) используются для хранения большого количества данных на более длительный срок.

Компьютер управляет этими различными видами памяти, чтобы максимально эффективно использовать ресурсы и 
обеспечивать быстрое и плавное выполнение задач. Идеально, чтобы часто используемые данные и 
инструкции были всегда доступны в наиболее быстрой памяти, т.е. в регистрах или кэше.
</details>

<details>
<summary>Структуры данных</summary><br>

Существует множество различных структур данных, каждая из которых имеет свои особенности и предназначение 
для определенных задач. Список основных структур данных:

1. **Массив (Array)**: Упорядоченная коллекция элементов одного типа, доступ к которым осуществляется по индексу.
2. **Список (List)**: Коллекция элементов, в которой каждый элемент содержит ссылку на следующий элемент. Существуют разные типы списков, такие как односвязные списки, двусвязные списки и т.д.
3. **Стек (Stack)**: Линейная структура данных, работающая по принципу "последним пришел, первым вышел" (`LIFO`). Используется для управления вызовами функций и временными данными.
4. **Очередь (Queue)**: Линейная структура данных, работающая по принципу "первым пришел, первым вышел" (`FIFO`). Используется, например, для обработки задач в порядке их поступления.
5. **Двусвязная очередь (Deque)**: Линейная структура данных, которая позволяет добавлять и удалять элементы как в начале, так и в конце.
6. **Связанный список (Linked List)**: Коллекция элементов, где каждый элемент (узел) содержит данные и ссылку на следующий (и, возможно, предыдущий) элемент.
7. **Дерево (Tree)**: Иерархическая структура данных, где элементы (узлы) связаны друг с другом в виде родительских и дочерних отношений.
8. **Бинарное дерево (Binary Tree)**: Дерево, в котором каждый узел имеет не более двух дочерних узлов.
9. **Куча (Heap)**: Древовидная структура данных, где каждый узел имеет значение, обычно упорядоченное относительно своих дочерних узлов.
10. **Граф (Graph)**: Структура данных, состоящая из вершин и рёбер, которые связывают эти вершины. Используется для моделирования связей между объектами.
11. **Хеш-таблица (Hash Table)**: Структура данных, которая использует хеш-функции для быстрого поиска значений по ключам.
12. **Строка (String)**: Коллекция символов, часто рассматриваемая как базовая структура данных.
</details>

<details>
<summary>Адресное пространство</summary><br>

**Адресное пространство** — это набор уникальных адресов, используемых для идентификации ячеек памяти в компьютере. 
В контексте операционных систем, адресное пространство обычно относится к диапазону адресов, которые процесс 
может использовать.

Важно отметить три основных типа адресных пространств:

1. **Физическое адресное пространство**: Это относится к реальным адресам физической памяти компьютера. Это прямое расположение данных в оперативной памяти компьютера.
2. **Виртуальное адресное пространство**: Операционные системы, поддерживающие виртуальную память, предоставляют каждому процессу иллюзию, что у него есть свое собственное непрерывное адресное пространство, изолированное от других процессов.
3. **Логическое (или относительное) адресное пространство**: Логические адреса представляют собой ссылки относительно начала некоторого контекста, например, области памяти процесса.

В современных операционных системах, таких как Windows, Linux и MacOS, для каждого запущенного процесса создается отдельное виртуальное адресное пространство. Это обеспечивает изоляцию и защиту памяти каждого процесса, предотвращая его случайное или намеренное воздействие на память других процессов. Такая система также значительно упрощает процесс программирования, поскольку программисты могут работать с виртуальной памятью, не заботясь о сложностях управления физической памятью.
</details>

<details>
<summary>Прерывания & таблица прерываний</summary><br>

**Прерывание (Interrupt)** - это сигнал, который генерируется аппаратным устройством, например, процессором
или внешним устройством (например, таймером или сетевой картой), чтобы прервать текущее выполнение 
программы и передать управление обработчику прерывания. Прерывания используются для обработки событий, 
требующих немедленного внимания, таких как внешние запросы на ввод-вывод, таймеры и другие аппаратные события.

**Таблица прерываний (Interrupt Table)** - это структура данных, используемая операционной системой для 
отображения аппаратных прерываний на соответствующие обработчики прерываний. Когда происходит прерывание, 
процессор использует таблицу прерываний для определения, какой обработчик прерывания следует вызвать.

Процесс работы с прерываниями выглядит следующим образом:

1. Аппаратное устройство генерирует прерывание, чтобы уведомить процессор об аппаратном событии.
2. Процессор приостанавливает текущее выполнение программы и проверяет таблицу прерываний, чтобы определить, какой обработчик прерывания следует вызвать.
3. Процессор передает управление обработчику прерывания, который выполняет специфические действия, связанные с обработкой прерывания.
4. По завершении обработки прерывания, процессор возвращает управление к выполнению прерванной программы.
Таблица прерываний обычно содержит для каждого аппаратного прерывания адрес обработчика прерывания в памяти. Когда происходит прерывание, процессор использует номер прерывания для доступа к соответствующему адресу в таблице прерываний и вызывает соответствующий обработчик.

Прерывания являются важным механизмом в операционных системах, позволяющим эффективно управлять аппаратными событиями и обеспечивать отзывчивость системы на внешние запросы.
</details>

<details>
<summary>Файловые системы</summary><br>

**Файловая система** - это метод организации данных, используемый в компьютере. Структура файловой системы 
включает такие элементы как файлы, каталоги (или папки) и корневой каталог для всей файловой системы.

1. **Файлы:** Файлы представляют собой базовые блоки информации в файловой системе. Каждый файл хранит некоторые данные и имеет уникальное имя.
2. **Каталоги:** Каталоги или папки предназначены для организации файлов. Они могут содержать файлы и другие каталоги, обеспечивая иерархическую структуру файловой системы.
3. **Корневой каталог:** На вершине иерархии файловой системы находится корневой каталог. Все файлы и каталоги в системе можно обратить по пути, начинающемуся от корневого каталога.

Реализация каталогов в файловой системе обычно зависит от специфической файловой системы, но общий принцип заключается в том, что каталог - это специальный тип файла, который содержит список файлов и каталогов, а также метаданные этих файлов и каталогов, такие как права доступа, даты создания и последнего изменения, владелец и т.д.

При обращении к каталогу файловая система читает его содержимое и представляет его пользователю или приложению в удобном виде. Переход от каталога к каталогу и выбор файла для чтения или записи выполняется поиском по списку внутри каждого каталога до тех пор, пока не будет найдена нужная позиция.

Иерархическая структура файловой системы обеспечивает возможность эффективной организации и навигации по большому количеству файлов и каталогов, а также контроля доступа к ним.

Виды файловых систем:

- **FAT (File Allocation Table)**: это старая и относительно простая файловая система, которая используется на многих системах, включая MS-DOS и ранние версии Windows.

- **NTFS (New Technology File System)**: это современная файловая система, разработанная Microsoft для Windows. Она обладает большой функциональностью, включающей поддержку больших файлов и томов, разрешения на файлы, сжатие, шифрование и журналирование для повышения надежности.

- **ext3, ext4 (Third Extended Filesystem, Fourth Extended Filesystem)**: это стандартные файловые системы для большинства дистрибутивов Linux. Они обладают многими функциями, включая журналирование и поддержку больших размеров файлов и файловых систем.

- **HFS+ и APFS (Hierarchical File System Plus, Apple File System)**: они используются в macOS. APFS — более новая система, включающая функции, такие как копирование на запись и шифрование на уровне файловой системы.

- **FAT32 и exFAT (Extended FAT)**: они используются для универсальных накопителей, таких как USB флэш-диски для обеспечения совместимости между различными операционными системами.

**Файл** — это единица хранения информации на компьютере. Можно сказать, что файл — это контейнер для данных. Файлы могут быть разных типов в зависимости от содержащихся в них данных, включая текстовые файлы, бинарные файлы, картинки, аудио и видео файлы, исполняемые файлы и т.д.
</details>

<details><summary>Виртуализация</summary><br>

**Виртуализация** - это процесс создания виртуальной (а не физической) версии чего-либо, включая (но не ограничиваясь) виртуальные аппаратные платформы, системы хранения данных, сетевые ресурсы и операционные системы.

Суть в разделении физической инфраструктуры на множество виртуальных "слоев". Вы можете запустить различные операционные системы и приложения на одном физическом сервере одновременно, что помогает оптимизировать использование ресурсов.

**Гипервизор**, или виртуальная машина монитор, это программное обеспечение, аппаратное обеспечение или прошивка, которая создает и запускает виртуальные машины. Гипервизор лежит в основе процесса виртуализации, он позволяет множеству ОС работать на одной физической машине, делая изоляцию каждой ОС и предоставляя ей доступ к физическим ресурсам машины.

Виртуализация и гипервизоры нашли широкое применение и используются для экономии на оборудовании, повышения эффективности использования ресурсов, ускорения процессов развертывания, тестирования и восстановления систем, а также для обеспечения безопасности приложений и данных.

</details>

### Технические вопросы
<details>
<summary>В чем заключаются две основные функции операционной системы?</summary><br>
Две основные функции операционной системы:

1. **Управление ресурсами**: Операционная система управляет и распределяет ресурсы компьютерной системы, такие как центральный процессор (CPU), память, дисковое пространство, периферийные устройства и сетевые ресурсы. Она контролирует доступ к этим ресурсам, планирует выполнение задач, управляет многозадачностью, обеспечивает изоляцию между процессами и обеспечивает эффективное использование оборудования.
2. **Предоставление сервисов**: Операционная система предоставляет набор сервисов и интерфейсов для пользователей и приложений. Эти сервисы включают файловую систему для управления файлами и папками, сетевые протоколы для обмена данными между компьютерами, интерфейсы взаимодействия с пользователем (графический интерфейс, командная строка) и многое другое. Операционная система также обеспечивает безопасность данных и доступа, контролируя права пользователей и обеспечивая механизмы аутентификации и авторизации.

Эти две основные функции операционной системы существенно способствуют эффективной и стабильной работе компьютерной системы, позволяя пользователям и приложениям взаимодействовать с аппаратурой и друг с другом.
</details>

<details>
<summary>Для использования кэш-памяти основная память делится на кэш-строки, которые 
обычно имеют длину 32 или 64 байта. Кэшируется сразу вся кэш-строка. В чем 
преимущество кэширования всей строки перед побайтным или пословным кэшированием?</summary><br>

Кэширование всей строки (или блока) данных в кэш-памяти вместо побайтного или пословного кэширования имеет несколько преимуществ:

1. **Принцип локальности**: Одним из ключевых принципов работы кэш-памяти является принцип локальности данных. Когда происходит обращение к определенному элементу данных, вероятность того, что будут использованы и другие данные в той же области памяти, весьма высока. Кэширование всей строки данных позволяет максимально использовать этот принцип, так как при обращении к одному элементу данных в кэш попадает сразу блок данных, содержащий близлежащие элементы.
2. **Снижение накладных расходов**: Обращение к памяти обычно сопровождается накладными расходами на поиск данных и передачу их в кэш. Когда кэшируется вся строка данных, накладные расходы становятся более эффективными. Если кэшировались бы только отдельные байты или слова, то накладные расходы могли бы быть значительно выше, так как для получения каждого отдельного элемента данных потребовалось бы дополнительных операций.
3. **Минимизация обращений к памяти**: Поскольку данные часто обрабатываются в виде последовательностей (например, массивы), кэширование целых строк данных уменьшает вероятность обращения к основной памяти для получения дополнительных данных. Это может существенно повысить производительность, так как обращение к основной памяти обычно требует большего времени по сравнению с доступом к кэшу.
</details>

<details>
<summary>Каждая операция чтения или записи байта на самых первых компьютерах управлялась 
центральным процессором (то есть без использования прямого доступа 
к памяти — DMA). Какие осложнения создавались тем самым для режима многозадачности?</summary><br>

Когда каждая операция чтения или записи байта управляется центральным процессором (CPU) без использования прямого доступа к памяти (DMA), это может создать несколько осложнений для режима многозадачности:

1. **Высокая загрузка процессора:** Если CPU занят непрерывными операциями чтения или записи данных, это может привести к тому, что другие задачи или процессы не получат достаточно процессорного времени для выполнения. Это может привести к снижению производительности и отзывчивости системы в целом.
2. **Задержки в многозадачности:** В случае, если CPU должен обрабатывать каждую операцию ввода-вывода в режиме многозадачности, это может привести к значительным задержкам. Другие задачи будут ожидать, пока CPU завершит операции ввода-вывода, что может вызвать плохое восприятие отзывчивости системы пользователем.
3. **Низкая эффективность:** Задачи, требующие интенсивного ввода-вывода, могут замедлять общую производительность системы, даже если они не требуют непосредственного процессорного времени. Это может стать барьером для эффективного использования вычислительных ресурсов.
4. **Ограниченная параллельность:** Когда процессор занят обработкой операций ввода-вывода, это может ограничить возможность одновременного выполнения других задач. Многозадачность стремится к эффективному использованию ресурсов, и если CPU постоянно занят вводом-выводом, это может уменьшить количество параллельно выполняемых задач.

В результате использования DMA и более эффективных методов обработки операций ввода-вывода, эти осложнения могут быть смягчены. DMA позволяет устройствам напрямую обмениваться данными с памятью, минимизируя вмешательство CPU. Это позволяет более гладко работать в режиме многозадачности и увеличивает производительность системы в целом.
</details>

<details>
<summary>Инструкции, касающиеся доступа к устройствам ввода-вывода, обычно относятся 
к привилегированным инструкциям, то есть они могут выполняться в режиме 
ядра, но не в пользовательском режиме. Назовите причину привилегированности 
этих инструкций.</summary><br>

Инструкции, связанные с доступом к устройствам ввода-вывода, обычно относятся к привилегированным инструкциям, потому что они могут иметь прямой доступ к оборудованию и влиять на внешние устройства. Это означает, что выполнение этих инструкций без ограничений может представлять риск для безопасности и стабильности системы. Вот несколько причин, почему инструкции ввода-вывода должны быть привилегированными:

1. **Безопасность:** Доступ к устройствам ввода-вывода может повлиять на работу всей системы и даже внешних устройств, таких как жесткие диски, сетевые адаптеры и другие. Если пользовательские программы имели бы прямой доступ к этим устройствам, это могло бы создать риски безопасности, например, возможность повреждения данных или внесения изменений в системные параметры.
2. **Стабильность системы:** Ошибки или некорректные операции с устройствами ввода-вывода могут повлиять на стабильность работы системы. Привилегированный доступ к этим инструкциям позволяет операционной системе контролировать и ограничивать действия пользовательских программ, чтобы предотвратить нарушение стабильности.
3. **Контроль и изоляция:** Привилегированные инструкции позволяют операционной системе лучше контролировать, какие программы и приложения имеют доступ к устройствам ввода-вывода. Они также позволяют обеспечить изоляцию между разными задачами и процессами, предотвращая их взаимное влияние на внешние устройства.
Таким образом, сделать инструкции ввода-вывода привилегированными помогает обеспечить безопасность, стабильность и эффективное управление системой в целом.
</details>

<details><summary>
При создании операционных систем одновременно решаются задачи, например, 
использования ресурсов, своевременности, надежности и т. д. Приведите пример 
такого рода задач, требования которых могут противоречить друг другу.</summary><br>

Проектирование операционных систем часто включает в себя решение комплекса задач, но некоторые из этих задач могут противоречить друг другу. Вот несколько примеров таких задач:

1. **Производительность и использование ресурсов:** Максимизация производительности может противоречить экономии ресурсов. Например, агрессивное использование процессорного времени и памяти может увеличить производительность приложений, но может также привести к ухудшению отзывчивости системы или даже к исчерпанию ресурсов для других задач.
2. **Своевременность и надежность:** Обеспечение своевременности выполнения задач (например, в системах реального времени) может столкнуться с проблемой обеспечения надежности. В некоторых случаях, чтобы соблюсти жесткие временные рамки, система может уступить в уровне контроля и обработки ошибок.
3. **Энергопотребление и производительность:** Оптимизация энергопотребления, чтобы увеличить время автономной работы ноутбуков или мобильных устройств, может оказать влияние на производительность, так как некоторые высокопроизводительные режимы могут быть ограничены для снижения энергопотребления.
4. **Безопасность и удобство использования:** Введение дополнительных механизмов безопасности может сделать систему более надежной, но в то же время может снизить удобство использования. Сложные процедуры аутентификации или авторизации могут создать неудобства для пользователей.
5. **Стабильность и инновации:** Поддержание стабильности операционной системы может противоречить внедрению новых инноваций и функциональности. Внесение слишком многих изменений может повысить риск несовместимости или неполадок.
6. **Масштабируемость и легковесность:** Создание операционной системы с высокой масштабируемостью для поддержки больших систем может противоречить усилиям по сделать систему легковесной и эффективной на маленьких устройствах.

В целом, балансирование между разными требованиями может быть сложной задачей при разработке операционных систем. Решение одной задачи может потребовать компромиссов в других аспектах, и инженеры операционных систем должны находить оптимальное решение, учитывая конкретные цели и сценарии использования.
</details>

<details><summary>
В чем разница между режимом ядра и пользовательским режимом? Объясните, 
как сочетание двух отдельных режимов помогает в проектировании операционных 
систем.</summary><br>

**Режим ядра** (также известный как режим привилегий) и **пользовательский режим** - это два отдельных уровня привилегий, в которых оперирует центральный процессор (CPU) при выполнении программ в операционной системе. Разница между этими режимами заключается в уровне доступа к ресурсам и инструкциям процессора.

**Режим ядра (Kernel Mode):**

- В этом режиме операционная система имеет полный доступ ко всем ресурсам и привилегиям компьютера, включая управление памятью, аппаратными устройствами и защитой.
- Операционная система выполняет критические задачи, такие как управление памятью, планирование задач, обработка аппаратных прерываний и обращение к аппаратным устройствам.
- Инструкции, выполняемые в режиме ядра, обычно привилегированные, что означает, что они могут выполнять операции, недоступные в пользовательском режиме.

**Пользовательский режим (User Mode):**

- В этом режиме программы выполняются с ограниченными привилегиями и ограниченным доступом к ресурсам системы.
- Ограничения пользовательского режима позволяют изолировать разные программы друг от друга, что обеспечивает стабильность и безопасность системы.
- В пользовательском режиме программа может выполнять только ограниченный набор инструкций и не имеет непосредственного доступа к аппаратным ресурсам.

Сочетание режима ядра и пользовательского режима является ключевым для проектирования операционных систем:

1. **Защита и изоляция:** Режим пользовательского режима обеспечивает изоляцию разных программ и пользователей друг от друга. Это позволяет предотвращать воздействие одной программы на работу другой и обеспечивает безопасность и стабильность системы.
2. **Управление ресурсами:** Режим ядра предоставляет операционной системе полный контроль над ресурсами и позволяет выполнять задачи, такие как управление памятью, планирование задач и обработка прерываний.
3. **Привилегированные задачи:** Режим ядра позволяет выполнение привилегированных задач, требующих доступа к аппаратным ресурсам и операциям, которые могут повлиять на весь компьютер.
4. **Безопасность:** Режим ядра позволяет контролировать, какие операции и ресурсы доступны программам в пользовательском режиме, обеспечивая защиту от злонамеренных или некорректных действий.

Таким образом, сочетание режимов ядра и пользовательского режима важно для обеспечения эффективного управления ресурсами, безопасности и стабильности операционной системы.
</details>

<details><summary>
Рассмотрим систему, имеющую два центральных процессора, у каждого из которых 
есть два потока (работающих в режиме гипертрейдинга). Предположим, есть три 
запущенные программы: P0, P1 и P2 со временем работы 5, 10 и 20 мс соответственно. Сколько времени займет полное выполнение этих программ? Следует 
принять во внимание, что все три программы загружают центральный процессор 
на 100 %, не осуществляют блокировку во время выполнения и не меняют центральный процессор, назначенный для их выполнения.
</summary><br>

В данном случае у вас есть два центральных процессора, каждый из которых имеет два потока (гипертреды), что обеспечивает вам четыре потока для выполнения задач.

Задачи P0, P1 и P2 занимают 5, 10 и 20 миллисекунд соответственно. Если каждая задача загружает центральный процессор на 100%, то время выполнения задачи в одном потоке будет равно времени работы задачи. Однако, если вы используете гипертрейдинг, то у вас есть четыре потока.

Поскольку у вас есть четыре потока и три задачи, вы можете начать выполнение всех трех задач одновременно. В таком случае, самая долгая задача (P2) займет 20 миллисекунд для своего выполнения.

Таким образом, время полного выполнения всех трех программ (P0, P1 и P2) составит 20 миллисекунд, так как задача P2 будет ограничивающим фактором.

</details>

<details><summary>
Компьютер обладает четырехступенчатым конвейером, и все ступени выполняют 
свою работу за одно и то же время — 1 нс. Сколько инструкций в секунду сможет 
выполнить эта машина?</summary><br>

Если компьютер обладает четырехступенчатым конвейером и каждая ступень выполняет работу за 1 нс, это означает, что за каждый такт может быть обработана одна часть работы четырех различных инструкций.

Так как на каждом такте обрабатывается четверть инструкции, то скорость выполнения инструкций будет равна 4 * 1 ГГц, что составляет 4 ГГц.

Это означает, что компьютер с четырехступенчатым конвейером сможет выполнить 4 миллиарда (4 * 10^9) инструкций в секунду.

</details>

<details><summary>
Рассмотрим компьютерную систему, имеющую кэш-память, ОЗУ и диск, а также 
операционную систему, использующую виртуальную память. Время доступа к сло-
ву из кэш-памяти занимает 1 нс, из ОЗУ — 10 нс, с диска — 10 мс. Если показатель 
успешного поиска в кэш-памяти составляет 95 %, в ОЗУ (после неудачного поиска 
в кэш-памяти) — 99 %, каким будет среднее время доступа к слову?</summary><br>

Для расчета среднего времени доступа к слову нам нужно учесть вероятности успешного и неудачного поиска в каждом из хранилищ: кэш-памяти, ОЗУ и диске.

1. Успешный поиск в кэш-памяти: 95% вероятность, время доступа 1 нс.
2. Неудачный поиск в кэш-памяти, успешный поиск в ОЗУ: 5% вероятность * 99% вероятность, время доступа 10 нс.
3. Неудачный поиск и в кэш-памяти, и в ОЗУ, успешный поиск на диске: 5% вероятность * 1% вероятность, время доступа 10 мс.
Теперь можно вычислить среднее время доступа:

Среднее время = (0,95 * 1 нс) + (0,05 * 0,99 * 10 нс) + (0,05 * 0,01 * 10 мс)
≈ 0,95 нс + 0,495 нс + 500 000 нс
≈ 500 001 нс

Таким образом, среднее время доступа к слову в данной системе составляет приблизительно 500 001 наносекунду, или 500 микросекунд.
</details>

<details><summary>
Что означает команда trap? Объясните ее использование в операционных системах.</summary><br>

Команда `trap` - это команда, используемая в командной оболочке (shell) операционных систем, чтобы перехватывать и обрабатывать сигналы. Сигналы - это асинхронные уведомления, которые отправляются процессам и приложениям для сообщения о различных событиях, таких как завершение выполнения, ошибка деления на ноль, прерывание пользовательской программы и т.д.

Команда `trap` позволяет настроить обработчики для сигналов, чтобы изменить стандартное поведение системы по умолчанию при получении сигнала. В общем смысле, она позволяет программистам и системным администраторам управлять поведением процессов в ответ на сигналы.

Пример использования команды `trap` в Unix-подобных операционных системах:

```bash
#!/bin/bash

# Установка обработчика для сигнала SIGINT (Ctrl+C)
trap 'echo "Ctrl+C pressed. Exiting..."; exit' INT

# Бесконечный цикл, ожидающий ввода пользователя
while true; do
  echo "Waiting for input..."
  read input
  echo "You entered: $input"
done
```

В этом примере, когда пользователь нажимает Ctrl+C, обработчик для сигнала `INT` будет выполнен, и программа выведет сообщение о нажатии Ctrl+C и завершится.

`trap` позволяет гибко управлять поведением программ при различных событиях, таких как завершение выполнения, ошибках или пользовательских запросах. Это может быть полезным для создания надежных и отзывчивых программ, а также для обработки различных сценариев в скриптах оболочки.

</details>

<details><summary>Для каждого из следующих системных вызовов назовите условия, при которых 
возникает ошибка: fork, exec и unlink.</summary><br>

**fork**: Ошибка при вызове `fork` может возникнуть, если достигнуто максимальное количество процессов, которое операционная система может поддерживать. Это может произойти, если система исчерпала доступные ресурсы для создания новых процессов, таких как память или идентификаторы процессов (PID).

**exec**: Ошибка при вызове `exec` может возникнуть, если указанный исполняемый файл не может быть найден. Это может произойти, если путь к файлу указан неверно или файл удален или перемещен. Также, если файл не имеет прав на выполнение, возникнет ошибка при попытке его запуска.

**unlink**: Ошибка при вызове `unlink` может возникнуть, если файл с указанным именем не существует или если у пользователя нет прав доступа на удаление этого файла. Также могут быть проблемы, связанные с правами доступа к каталогу, в котором расположен файл, или с монтированными файловыми системами.

</details>

<details><summary>В современных операционных системах адресное пространство процесса отделено 
от физической памяти машины. Назовите два преимущества такой конструкции.</summary><br>

Разделение адресного пространства процесса и физической памяти в современных операционных системах предоставляет несколько преимуществ:

1. **Защита памяти:** Разделение адресного пространства позволяет изолировать процессы друг от друга. Каждый процесс видит свою собственную виртуальную память, и доступ к памяти другого процесса ограничен. Это предотвращает случайные или вредоносные действия одного процесса от повреждения памяти других процессов. Если один процесс попытается обратиться к памяти другого процесса, операционная система сможет обнаружить это и прервать некорректные действия.
2. **Управление памятью и виртуализация:** Разделение адресного пространства позволяет операционной системе более эффективно управлять физической памятью и ее выделением для различных процессов. Операционная система может использовать техники, такие как страничное разделение и подкачка страниц, чтобы оптимизировать использование доступной памяти и обеспечить максимальную производительность. Виртуализация памяти также позволяет каждому процессу оперировать с большим адресным пространством, чем фактически доступно физической памяти.

Эти преимущества обеспечивают более надежную и эффективную работу многозадачных операционных систем, позволяя процессам функционировать изолированно и безопасно в раздельных виртуальных адресных пространствах.

</details>

### Список литературы
- Таненбаум Э. С., Бос Х. Современные операционные системы.
- Таненбаум Э. С. Архитектура компьютера.
- Operating Systems (three easy pieces) Remzi H., Andrea C.