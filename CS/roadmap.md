# Computer Science

Прежде чем приступать к изучению основной части, стоит уделить внимание такой науке, как `Computer Science`. 
Вот основные причины:
1. **Общие понятия:** `Computer Science` является основой для того, чтобы узнать, как именно работают компьютеры и программное обеспечение. От архитектуры компьютера до понятия как работают сети. Эти знания помогают DevOps-специалистам лучше понимать, как развертывать, масштабировать и управлять сложными системами.
2. **Программирование и скриптовые языки:** DevOps часто требует написания или изменения скриптов и кода. Базовые навыки программирования и понимание алгоритмов, полученные из Computer Science, будут здесь невероятно полезными.
3. **Базы данных:** Понимание структуры и функционирования баз данных является важным элементом для эффективного управления данными и ресурсами, что часто встречается в задачах DevOps.
4. **Теория систем:** DevOps-специалистам необходимо управлять и обслуживать различные системы. Понимание принципов работы операционных систем, компьютерных сетей и облачных вычислений - это ключевая составляющая образования в Computer Science, которая будет полезна в DevOps.
5. **TroubleShooting:** Наука о компьютерах учит навыкам, необходимым для решения сложных и технических проблем, которые часто возникают в рабочем процессе DevOps.

Ну и наверное самая основная причина - DevOps-инженер прежде всего технический специалист, который понимает как работают все процессы. Многие крупные компании готовы нанимать специалистов, 
которые обладают отличными общими инженерными компетенциями. В таком случае возможно попасть на хорошую вакансию даже без знания других технических инструментов. Так как считается, что такой инженер сможет быстро освоить и другие технологии.

`Computer Science` очень обширная наука, полностью разобрать ее на площадке вряд ли получится. Поэтому предлагаю пройтись по перечню основных тем и 
более углубленно их изучить уже самостоятельно с дополнительной литературой. Список вопросов будет в конце фрагмента.

Основа Computer Science на практике - решение алгоритмических задач.

### Список тем:

<details>
<summary>Основные компоненты компьютера</summary><br>

- **Центральный процессор (CPU)**: Основной вычислительный компонент, выполняющий инструкции программы и управляющий работой остальных компонентов.

- **Оперативная память (RAM)**: Временное хранилище данных и программ, с которыми процессор взаимодействует в режиме реального времени.

- **Жесткий диск (HDD) или твердотельный накопитель (SSD)**: Устройство для долгосрочного хранения данных, операционной системы и программ.

- **Материнская плата**: Основная плата, на которой установлены и связаны между собой все остальные компоненты, включая ЦП, ОЗУ и различные порты.

- **Графический процессор (GPU)**: Отвечает за обработку графики, 3D-визуализацию, а также вычисления в областях, требующих большой вычислительной мощности.

- **Звуковая карта**: Обеспечивает воспроизведение и запись звука, а также поддерживает аудиоинтерфейсы.

- **Сетевая карта**: Позволяет компьютеру подключаться к сетям, включая интернет, через проводное или беспроводное соединение.

- **Устройства ввода-вывода**: Разнообразные разъемы для подключения устройств ввода (клавиатура, мышь) и вывода (монитор, принтер и т.д.).

- **Периферийные устройства (PCI)**: Внешние устройства, такие как принтеры, сканеры, внешние жесткие диски и др.
</details>

<details>
<summary>Операционная система</summary><br>

Операционная система — это системное программное обеспечение, которое предоставляет интерфейс для взаимодействия пользовательских приложений с оборудованием компьютера. 
Она управляет и координирует деятельность оборудования и софта, выступая между ними в качестве посредника.
Операционная система отвечает за разнообразный спектр функций, включая:

1. **Управление процессами**: ОС организует различные процессы и программы на компьютере, обеспечивая их аккуратное выполнение.
2. **Управление памятью**: ОС контролирует распределение и использование оперативной и долговременной памяти компьютера.
3. **Планирование задач**: ОС определяет, как и когда процессы должны быть выполнены.
4. **Взаимодействие с оборудованием**: ОС обеспечивает доступ к аппаратным ресурсам компьютера, таким как дисковое пространство, принтеры или другие периферийные устройства.
5. **Предоставление интерфейса для пользователя**: ОС предлагает графический пользовательский интерфейс (GUI), с которым пользователь может взаимодействовать, чтобы выполнить различные задачи.
6. **Управление файлами и файловыми системами**: ОС управляет файлами и файловыми системами, обеспечивая доступ, хранение, поиск и манипуляцию данными.
7. **Управление безопасностью**: ОС предлагает функции защиты и безопасности, ограничивая доступ к ресурсам, отслеживая активность и защищая от вирусов или другого вредоносного ПО.

Основные ОС: `Microsoft Windows`, `Mac OS`, `Linux` и `Android`.
</details>

<details>
<summary>Ядро ОС (Kernel)</summary><br>

**Ядро** — это центральная часть операционной системы. Оно обеспечивает низкоуровневое взаимодействие 
программного обеспечения с аппаратными ресурсами компьютера, а также управляет системными ресурсами, 
например, контролирует выполнение процессов, управляет памятью, взаимодействует с устройствами 
ввода-вывода и обеспечивает сетевые функции.

Ядро предназначено для:

1. **Управление процессами и потоками**: Ядро принимает решения о том, когда и как долго процессы и потоки должны выполняться. Оно также обрабатывает создание, завершение и синхронизацию процессов и потоков.
2. **Управление памятью**: Ядро управляет распределением и освобождением памяти, а также обеспечивает защиту памяти и механизмы виртуальной памяти.
3. **Обработка ввода / вывода и управление устройствами**: Ядро обеспечивает взаимодействие с устройствами ввода/вывода, такими как жесткий диск, клавиатура, мышь и принтер, управляет драйверами устройств и распределяет ресурсы между устройствами.
4. **Управление системными вызовами**: Ядро предоставляет программам интерфейс для доступа к аппаратным и системным ресурсам через системные вызовы.
5. **Обеспечение безопасности**: Ядро предоставляет функции безопасности, такие как контроль доступа, изоляция процессов и управление пользователями и группами пользователей.
Ядро играет ключевую роль в работе операционной системы, обеспечивая стабильное и безопасное функционирование системы в целом.
</details>

<details>
<summary>Загрузка ОС</summary><br>

**Загрузка операционной системы**, или процесс загрузки (booting), это процесс, при котором компьютер
собирает информацию из различных системных компонентов и загружает операционную систему в память
для выполнения. Вот типичная последовательность шагов, происходящих при старте компьютера:

1. **Пусковой тест при включении (POST)**: Когда компьютер впервые включается, он выполняет `POST` (Power-On Self Test). В этом тесте BIOS (базовая система ввода-вывода) проверяет аппаратное обеспечение компьютера, чтобы убедиться, что все работает корректно.
2. **Стадия загрузки в BIOS/UEFI**: После `POST`, BIOS или его современный эквивалент `UEFI` запускается и ищет загрузочное устройство (обычно это жесткий диск, но это также может быть CD/DVD-диск, USB-устройство или сетевое устройство).
3. **Загрузчик Bootloader**: `BIOS` или `UEFI` затем запускают bootloader с загрузочного устройства. Bootloader, такой как GRUB для Linux или Boot Manager для Windows, загружает основное ядро операционной системы.
4. **Загрузка ядра ОС**: Ядро ОС, при загрузке, выполняет инициализацию системных ресурсов, загружает драйверы устройств, инициализирует процессы и запускает менеджер системы или супервайзер (например, systemd на Linux, или Service Control Manager на Windows).
5. **Запуск сеанса пользователя**: После того, как все системные службы были загружены, следующий шаг — это запуск пользовательского интерфейса, такого как графический интерфейс (GUI) или командная строка (CLI). В случае GUI, этот процесс обычно заключается в запуске программы входа в систему, которая ждет, пока пользователь введет имя пользователя и пароль.
6. **Запуск пользовательских программ**: После успешного входа в систему, запускаются пользовательские программы и службы, включая всё, что указано в настройках автозагрузки.

После всех этих шагов компьютер готов к работе, и пользователь может начинать использовать систему.
</details>

<details>
<summary>Архитектура ОС</summary><br>

**Архитектура операционной системы** описывает организацию компонентов, структуру и взаимодействие между ними внутри операционной системы. Существует несколько распространенных архитектурных подходов, на которых строятся операционные системы. Ниже представлен обзор некоторых типов архитектур операционных систем:

- **Монолитная архитектура (Monolithic Architecture)**:
В монолитной архитектуре все компоненты операционной системы, такие как файловая система, планировщик задач, драйверы устройств и т.д., находятся в одной большой программе (ядре операционной системы). Взаимодействие между компонентами обеспечивается вызовами функций. Это простой подход, но может привести к сложностям при обновлениях и модификациях системы.

- **Микроядерная архитектура (Microkernel Architecture)**:
В этой архитектуре ядро операционной системы содержит только основные функции, такие как планирование задач, управление памятью и межпроцессное взаимодействие. Остальные сервисы, такие как файловые системы и драйверы устройств, работают как пользовательские процессы. Это уменьшает сложность ядра и облегчает расширение и обновление системы, но может привести к ухудшению производительности из-за повышенных накладных расходов на межпроцессное взаимодействие.

- **Модульная архитектура (Modular Architecture)**:
Это комбинация монолитной и микроядерной архитектур. Операционная система разделяется на модули, каждый из которых отвечает за определенный аспект, например, файловую систему, сетевые службы и др. Эти модули могут работать в контексте ядра или как пользовательские процессы.

- **Виртуальная машина (Virtual Machine) или Гипервизор**:
В этом случае операционная система работает на уровне виртуальной машины, которая может поддерживать выполнение нескольких операционных систем на одном физическом компьютере. Этот подход позволяет изолировать разные системы и обеспечивает высокий уровень гибкости, но может потребовать больше вычислительных ресурсов.

Реальные операционные системы могут использовать комбинации этих подходов и включать другие дополнительные аспекты, такие как безопасность, многозадачность и управление ресурсами.
</details>

<details>
<summary>Оболочка (Shell)</summary><br>

**Оболочка (shell)** в операционных системах — это программный интерфейс, который предоставляет пользователям доступ к основным сервисам операционной системы.

Оболочка может быть графической (GUI), такой как Windows Shell в операционной системе Windows или рабочий стол GNOME в Linux. Однако, термин обычно используется в контексте командной строки или текстового интерфейса (CLI), такого как Bash (Bourne Again Shell) в Unix или Linux, или командный интерпретатор (cmd) в Windows.

Оболочка позволяет пользователю осуществлять различные операции, вроде управления файлами и директориями, запуска программ, управления процессами, и даже кодирования скриптов для автоматизации задач. Все это выполнимо при помощи специальных команд, вводимых в текстовый интерфейс.

Оболочка служит важным инструментом коммуникации между пользователем и операционной системой.
</details>

<details>
<summary>Режимы привилегий</summary><br>

**Режим ядра (Kernel Mode) и режим пользователя (User Mode) - это уровни привилегий, в которых работает центральный процессор компьютера при выполнении программ.**

1. **Режим ядра (Kernel Mode)**:
В этом режиме операционная система имеет полный доступ ко всем ресурсам и привилегиям компьютера.
Операционная система выполняет критические задачи, такие как управление памятью, планирование задач, обработка аппаратных прерываний и взаимодействие с аппаратными устройствами.
Инструкции, выполняемые в режиме ядра, обычно являются привилегированными, то есть они могут выполнять операции, которые не доступны в режиме пользователя.
2. **Режим пользователя (User Mode)**:
В этом режиме программы, выполняющиеся на компьютере, работают с ограниченными привилегиями и доступом к ресурсам.
Программы в режиме пользователя обычно не имеют прямого доступа к аппаратным ресурсам и выполнению критических операций.
Операции, выполняемые в режиме пользователя, должны быть разрешены операционной системой, которая контролирует доступ к ресурсам и обеспечивает безопасность.


**Зачем нужны режимы привилегий:**
- Режимы привилегий важны для обеспечения безопасности, стабильности и контроля в компьютерных системах. Они позволяют операционной системе разграничивать доступ к ресурсам и управлять выполнением задач. Вот некоторые основные причины:

- Изоляция и защита: Режимы позволяют изолировать различные программы и процессы друг от друга. Это предотвращает вмешательство и воздействие одной программы на другую.

- Безопасность: Режим ядра обеспечивает контроль над выполнением операций с высокими привилегиями. Это позволяет избегать незаконных или потенциально опасных действий.

- Стабильность: Режим ядра контролирует аппаратные ресурсы и обеспечивает выполнение критических задач, таких как планирование задач и управление памятью.

- Контроль доступа: Режимы позволяют операционной системе управлять доступом программ к ресурсам, таким как память, файлы и аппаратные устройства.

- Предотвращение конфликтов: Режимы помогают предотвращать конфликты и состязания между программами за ресурсы.

- Режимы ядра и пользователя играют важную роль в обеспечении безопасности, эффективности и стабильности работы компьютерных систем.
</details>

<details>
<summary>POSIX</summary><br>

**POSIX (Portable Operating System Interface)** — это набор стандартов, разработанных Институтом инженеров электротехники 
и электроники (IEEE), чтобы обеспечить совместимость между операционными системами.

`POSIX` определяет интерфейс операционной системы, который должен использоваться для обеспечения портабельности 
программного обеспечения. Это включает в себя аспекты, такие как работа с файлами и каталогами, управление процессами
и потоками, а также обработка сигналов.

Поскольку большинство UNIX-подобных операционных систем (`Linux`, `MacOS`, `FreeBSD`, `OpenBSD`, `NetBSD`, `Solaris`), следуют стандартам POSIX, программное
обеспечение, написанное в соответствии с этими стандартами, может быть запущено на любой из этих систем без 
значительной модификации кода.

Важно отметить, что `POSIX` — это не операционная система, а набор стандартов, которые помогают разработчикам 
программного обеспечения создавать кросс-платформенные программы.
</details>

<details>
<summary>Системные вызовы</summary><br>

**Системные вызовы (system calls)** — это интерфейс (функции) между пространством пользователя и пространством ядра в 
операционных системах. Эти функции, предоставляются ядром операционной системы. Они позволяют программам
в пространстве пользователя взаимодействовать с системными ресурсами или осуществлять операции, которые 
обычно доступны только операционной системе.

Основные системные вызовы включают следующие:

- **Управление процессами**: Создание, завершение, ожидание и планирование процессов. В библиотеке `POSIX` эти функции обычно называются `fork(), exit(), wait(), exec()`, и т.д.

- **Управление памятью**: Выделение, освобождение памяти, а также защита областей памяти. Примеры таких системных вызовов — `brk(), mmap(), mprotect(), munmap()`.

- **Управление файлами**: Открытие, чтение, запись, закрытие файлов, а также операции с каталогами. Примеры таких системных вызовов — `open(), read(), write(), close(), mkdir(), rmdir(), stat(), fstat(),lstat()` и другие.

- **Управление устройствами**: Контроль над вводом-выводом и другими устройствами. Примеры системных вызовов включают `ioctl(), read(), write()`.

- **Коммуникация между процессами (IPC)**: Семафоры, сообщения, разделяемая память и др. Примеры тут могут быть `semop(), msgsnd(), msgrcv(), shmget()` и т.д.

- **Сетевые функции**: Сетевые операции, включая сокеты. Примеры системных вызовов включают `socket(), bind(), connect(), listen(), accept(), send(), receive()`.

Системные вызовы служат мостом между программами пользователя и возможностями ядра операционной системы, позволяя при этом поддерживать необходимый контроль и безопасность.
</details>

<details>
<summary>Мультиплексирование</summary><br>

**Мультиплексирование** - распределение ресурсов в ОС двумя различными способами: во времени и в пространстве.
Когда ресурс разделяется во времени, различные программы или пользователи используют его по
очереди: сначала ресурс получают в пользование одни, потом другие и т.д. Другим видом разделения ресурсов является пространственное разделение. Вместо
поочередной работы каждый клиент получает какую-то часть разделяемого ресурса.
</details>

<details>
<summary>Потоки и процессы</summary><br>

**Процесс** — это экземпляр программы, которая выполняется на компьютере. Каждый процесс имеет свою собственную область памяти и свое состояние. Он также содержит информацию о своем выполнении, включая значение счетчика команд и значения регистров. Процессы могут взаимодействовать друг с другом через системные вызовы для межпроцессного взаимодействия (IPC).

**Поток**, с другой стороны, иногда называемый "легким" процессом, — это отдельная последовательность выполнения в рамках процесса. Потоки в одном процессе разделяют ту же область памяти и ресурсы, что и сам процесс, что позволяет потокам эффективно обмениваться данными друг с другом. Индивидуальный поток имеет собственный счетчик команд, стек и состояние регистров.

Вот несколько ключевых отличий между процессами и потоками:

- **Независимость**: Процессы являются боле независимыми друг от друга по сравнению с потоками. Если один процесс падает или зависает, это обычно не влияет на другие процессы. С другой стороны, если один поток в процессе падает, это обычно приводит к падению всего процесса.

- **Расходы на переключение**: Переключение между потоками в пределах одного процесса обычно менее ресурсоемко, чем переключение между процессами, поскольку потоки разделяют общее адресное пространство.

- **Общение и синхронизация**: Поскольку потоки в одном процессе разделяют общую память, взаимодействие и синхронизация между ними обычно проще, чем между процессами. Тем не менее, это также может привести к сложностям, таким как состояния гонки, если не обеспечивается должная синхронизация.

- **Ресурсы**: Каждый процесс имеет свой собственный набор ресурсов, в то время как все потоки в пределах одного процесса разделяют ресурсы.

Оба этих понятия играют ключевую роль в многозадачности, позволяя операционной системе максимально эффективно использовать процессорное время и ресурсы.
</details>

<details>
<summary>Цикл жизни процессов</summary><br>

**Цикл жизни процесса** — это последовательность состояний, через которые проходит процесс при его создании, выполнении, завершении и управлении операционной системой. Обычно цикл жизни процесса включает следующие этапы:

- **Создание (Creation)**:
Процесс создается при необходимости выполнения определенной задачи. В этом этапе операционная система выделяет ресурсы, такие как память, инициализирует регистры и данные процесса. Процесс также получает уникальный идентификатор (PID).

- **Готовность (Ready)**:
После создания процесс переходит в состояние готовности. В этом состоянии процесс ожидает выделения процессорного времени, чтобы начать выполнение. На этом этапе он находится в очереди процессов, готовых к выполнению.

- **Выполнение (Running)**:
Когда процесс получает процессорное время, он переходит в состояние выполнения. Процессор выполняет инструкции этого процесса. В многозадачных системах процессы могут переключаться между состояниями выполнения и готовности.

- **Ожидание (Waiting или Blocked)**:
Если процесс ожидает выполнения какого-либо события (например, ввода-вывода), он переходит в состояние ожидания. В этом состоянии процесс не выполняется, и операционная система может выделить процессорное время другому процессу.

- **Завершение (Termination)**:
Процесс завершается, когда он выполнил свою задачу или был принудительно завершен операционной системой. На этом этапе освобождаются ресурсы, выделенные процессу, и его запись удаляется из списка активных процессов.

- **Зомби (Zombie)**:
Процесс переходит в состояние зомби, когда он завершается, но его родительский процесс ещё не запросил 
статус завершения этого процесса. В этот момент операционная система сохраняет некоторую информацию о 
завершенном процессе, чтобы родительский процесс мог в дальнейшем запросить этот статус.

Обратите внимание, что процессы могут переходить между этими состояниями в зависимости от внешних событий и алгоритмов планирования операционной системы. Цикл жизни процесса демонстрирует, как операционная система управляет процессами и ресурсами для обеспечения эффективного выполнения задач.
</details>

<details>
<summary>Многопоточное выполнение программ</summary><br>

**Многопоточное выполнение программ** — это метод, при котором одна программа выполняется как несколько 
параллельных процессов или "потоков".

Потоки обрабатываются независимо друг от друга, каждый имеет собственные регистры процессора, 
собственное состояние и собственный область стека в памяти. Однако все потоки одного процесса 
разделяют общее адресное пространство, что позволяет им обмениваться данными и взаимодействовать
друг с другом намного быстрее, чем отдельные процессы.

Многопоточность используется во многих сценариях, включая следующие:

- **Обработка ввода/вывода и вычисления**: в программе можно использовать один поток для чтения данных или ожидания пользовательского ввода, в то время как другой поток может выполнять вычисления или обрабатывать данные.

- **Параллельное выполнение**: если у вас есть многоядерный процессор или несколько процессоров, многопоточное выполнение позволяет программе использовать все ядра одновременно, повышая производительность.

- **Обработка нескольких запросов**: в серверных приложениях, например, веб-серверах, каждый входящий запрос может быть обработан в отдельном потоке, обеспечивая эффективное распределение нагрузки.

Однако многопоточность также приносит свои проблемы, такие как сложности синхронизации потоков. Кроме того, из-за разделяемого состояния потоков возможно появление состояния гонки (race condition), когда два или более потока пытаются изменить общую переменную одновременно.
</details>

<details>
<summary>Память</summary><br>

**Память** в компьютере имеет иерархию, которая определяется скоростью, емкостью и стоимостью компонентов. 
Основные виды памяти включают:

- **Регистры процессора**: Это наиболее быстрый тип памяти в компьютере. Регистры процессора хранят данные, непосредственно участвующие в текущих вычислениях.

- **Кэш-память**: Кэш-память — это небольшой объем высокоскоростной памяти, расположенной непосредственно на процессоре или рядом с ним. Уровни кэш-памяти (L1, L2, L3) отличаются по размеру и скорости доступа.

- **Оперативная память (RAM)**: RAM — это основное рабочее пространство компьютера, где он хранит данные и программы, над которыми в данный момент осуществляются операции. Она значительно больше по объему, чем кэш или регистры, но и немного медленнее по скорости.

- **Память виртуальная**: Когда оперативной памяти (RAM) не хватает для работы всех процессов, операционная система может использовать часть жесткого диска в качестве памяти. Это называется виртуальной памятью. Она значительно медленнее по сравнению с оперативной памятью.

- **Постоянная память (ROM, SSD, HDD)**: Это память компьютера, которая сохраняет информацию даже после выключения питания. Она используется для хранения операционной системы, приложений и личных файлов пользователя. ROM (Read-Only Memory) используется для хранения фиксированной информации, которую требуется загрузить при включении компьютера. SSD (Solid State Drives) и HDD (Hard Disk Drives) используются для хранения большого количества данных на более длительный срок.

Компьютер управляет этими различными видами памяти, чтобы максимально эффективно использовать ресурсы и 
обеспечивать быстрое и плавное выполнение задач. Идеально, чтобы часто используемые данные и 
инструкции были всегда доступны в наиболее быстрой памяти, т.е. в регистрах или кэше.
</details>

<details>
<summary>Структуры данных</summary><br>

Существует множество различных структур данных, каждая из которых имеет свои особенности и предназначение 
для определенных задач. Список основных структур данных:

1. **Массив (Array)**: Упорядоченная коллекция элементов одного типа, доступ к которым осуществляется по индексу.
2. **Список (List)**: Коллекция элементов, в которой каждый элемент содержит ссылку на следующий элемент. Существуют разные типы списков, такие как односвязные списки, двусвязные списки и т.д.
3. **Стек (Stack)**: Линейная структура данных, работающая по принципу "последним пришел, первым вышел" (`LIFO`). Используется для управления вызовами функций и временными данными.
4. **Очередь (Queue)**: Линейная структура данных, работающая по принципу "первым пришел, первым вышел" (`FIFO`). Используется, например, для обработки задач в порядке их поступления.
5. **Двусвязная очередь (Deque)**: Линейная структура данных, которая позволяет добавлять и удалять элементы как в начале, так и в конце.
6. **Связанный список (Linked List)**: Коллекция элементов, где каждый элемент (узел) содержит данные и ссылку на следующий (и, возможно, предыдущий) элемент.
7. **Дерево (Tree)**: Иерархическая структура данных, где элементы (узлы) связаны друг с другом в виде родительских и дочерних отношений.
8. **Бинарное дерево (Binary Tree)**: Дерево, в котором каждый узел имеет не более двух дочерних узлов.
9. **Куча (Heap)**: Древовидная структура данных, где каждый узел имеет значение, обычно упорядоченное относительно своих дочерних узлов.
10. **Граф (Graph)**: Структура данных, состоящая из вершин и рёбер, которые связывают эти вершины. Используется для моделирования связей между объектами.
11. **Хеш-таблица (Hash Table)**: Структура данных, которая использует хеш-функции для быстрого поиска значений по ключам.
12. **Строка (String)**: Коллекция символов, часто рассматриваемая как базовая структура данных.
</details>

<details>
<summary>Адресное пространство</summary><br>

**Адресное пространство** — это набор уникальных адресов, используемых для идентификации ячеек памяти в компьютере. 
В контексте операционных систем, адресное пространство обычно относится к диапазону адресов, которые процесс 
может использовать.

Важно отметить три основных типа адресных пространств:

1. **Физическое адресное пространство**: Это относится к реальным адресам физической памяти компьютера. Это прямое расположение данных в оперативной памяти компьютера.
2. **Виртуальное адресное пространство**: Операционные системы, поддерживающие виртуальную память, предоставляют каждому процессу иллюзию, что у него есть свое собственное непрерывное адресное пространство, изолированное от других процессов.
3. **Логическое (или относительное) адресное пространство**: Логические адреса представляют собой ссылки относительно начала некоторого контекста, например, области памяти процесса.

В современных операционных системах, таких как Windows, Linux и MacOS, для каждого запущенного процесса создается отдельное виртуальное адресное пространство. Это обеспечивает изоляцию и защиту памяти каждого процесса, предотвращая его случайное или намеренное воздействие на память других процессов. Такая система также значительно упрощает процесс программирования, поскольку программисты могут работать с виртуальной памятью, не заботясь о сложностях управления физической памятью.
</details>

<details>
<summary>Файловые системы</summary><br>

**Файловая система** — это метод организации и хранения информации на носителе данных, например, на жестком диске, SSD, USB-накопителе, CD/DVD или в облачном хранилище. Файловая система определяет, как файлы и каталоги структурированы на диске и как операционная система с ними взаимодействует.

Виды файловых систем включают:

- **FAT (File Allocation Table)**: это старая и относительно простая файловая система, которая используется на многих системах, включая MS-DOS и ранние версии Windows.

- **NTFS (New Technology File System)**: это современная файловая система, разработанная Microsoft для Windows. Она обладает большой функциональностью, включающей поддержку больших файлов и томов, разрешения на файлы, сжатие, шифрование и журналирование для повышения надежности.

- **ext3, ext4 (Third Extended Filesystem, Fourth Extended Filesystem)**: это стандартные файловые системы для большинства дистрибутивов Linux. Они обладают многими функциями, включая журналирование и поддержку больших размеров файлов и файловых систем.

- **HFS+ и APFS (Hierarchical File System Plus, Apple File System)**: они используются в macOS. APFS — более новая система, включающая функции, такие как копирование на запись и шифрование на уровне файловой системы.

- **FAT32 и exFAT (Extended FAT)**: они используются для универсальных накопителей, таких как USB флэш-диски для обеспечения совместимости между различными операционными системами.

**Файл** — это единица хранения информации на компьютере. Можно сказать, что файл — это контейнер для данных. Файлы могут быть разных типов в зависимости от содержащихся в них данных, включая текстовые файлы, бинарные файлы, картинки, аудио и видео файлы, исполняемые файлы и т.д.
</details>