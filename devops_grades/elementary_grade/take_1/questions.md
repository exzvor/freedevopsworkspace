### git
<details><summary>Как узнать, является ли определенный каталог git-репозиторием?</summary><br>

Чтобы узнать, является ли определенный каталог git-репозиторием, можно воспользоваться командой `git status`.

Если текущий каталог является частью git-репозитория, вы увидите информацию о текущем состоянии репозитория, например, какие файлы изменены и какие файлы готовы к коммиту.

Если каталог не является частью git-репозитория, вы увидите сообщение о том, что не удалось выполнить команду, так как не найдено git-репозитория.

</details>

<details><summary>Что такое git directory, working directory и staging area?</summary><br>

В Git существуют три основных компонента, которые играют ключевую роль в управлении версиями и отслеживании изменений в проекте:

**Git Directory (Репозиторий):** Это скрытая директория .git, которая находится в корне вашего проекта. В ней хранится вся история изменений, информация о ветках, конфигурационные файлы и прочие данные, необходимые Git для управления репозиторием.

**Working Directory (Рабочая директория):** Это директория на вашем компьютере, где расположены файлы и папки вашего проекта. Рабочая директория представляет собой текущее состояние проекта, над которым вы работаете.

**Staging Area (Индекс):** Это промежуточная зона, где вы подготавливаете изменения к коммиту. Файлы, добавленные в индекс, будут включены в следующий коммит. Стэйджинг обычно представляет собой снимок состояния вашего проекта на момент подготовки к коммиту.

Давайте рассмотрим типичный процесс работы с Git, включая эти три компонента:

1) Работа с файлами в рабочей директории: Вы вносите изменения в файлы в рабочей директории, создаете новые файлы и удаляете существующие.
2) Добавление файлов в индекс (Staging Area): После внесения изменений вы используете git add для добавления файлов или изменений в индекс. Таким образом, вы сообщаете Git, какие изменения вы хотите включить в следующий коммит.
3) Коммит изменений: После того как вы подготовили все необходимые изменения в индексе, вы используете git commit для создания коммита. В этот момент Git создает постоянную запись о текущем состоянии проекта в истории репозитория.
4) Повторение процесса: Этот процесс повторяется в цикле: внесение изменений, подготовка к коммиту, создание коммита.


Использование этих трех компонентов позволяет эффективно управлять версиями вашего проекта в Git.

</details>

<details><summary>В чем разница между git pull и git fetch?</summary><br>

`git pull` и `git fetch` - это две разные команды в Git, которые позволяют обновить ваш локальный репозиторий на основе изменений, произошедших в удаленном репозитории. Однако они выполняют эту задачу немного по-разному.

Вот основные различия между ними:


Команда **`git fetch`** извлекает все данные из удаленного репозитория, но не вливает их в вашу локальную ветку. Она просто загружает новые данные, обновляя информацию о ветках в вашем локальном репозитории.

Это безопасная операция, так как не меняет вашу текущую рабочую директорию и не приводит к конфликтам.

После выполнения `git fetch`, вы можете просмотреть новые изменения и решить, хотите ли вы объединить их с вашим текущим состоянием.


Команда **`git pull`** комбинирует две операции: `git fetch` для загрузки новых данных из удаленного репозитория и затем `git merge` (или `git rebase` в зависимости от настроек) для объединения этих изменений с вашей текущей веткой.

Это удобно, когда вы хотите быстро обновить свою локальную ветку до последней версии из удаленного репозитория.

Однако, если есть конфликты между вашими изменениями и изменениями из удаленного репозитория, `git pull` попытается автоматически объединить изменения, что может привести к конфликтам.

Когда использовать что:

Используйте `git fetch`, если вы хотите просто получить последние изменения из удаленного репозитория, но пока не готовы вливать их в вашу текущую ветку.

Используйте `git pull`, если вы хотите быстро обновить вашу локальную ветку до последней версии из удаленного репозитория и готовы сразу же вливать эти изменения.

Обе команды имеют свои сценарии применения, и выбор между ними зависит от текущей ситуации и ваших предпочтений в работе с версиями.

</details>

<details><summary>Объясните зачем нужен файл .gitignore?</summary><br>

Файл `.gitignore` в Git используется для указания файлов и папок, которые не должны быть учитываться системой контроля версий. Это позволяет игнорировать временные, созданные сборочными инструментами или локальные файлы, которые не должны попадать в репозиторий.

Причины, почему файл `.gitignore` полезен:

1) Игнорирование временных файлов и кеша:
- В процессе разработки создаются временные файлы и кеш, которые не имеют ценности для хранения в репозитории. Файл .gitignore позволяет автоматически исключать их из контроля версий.
2) Игнорирование конфигурационных файлов:
- Конфигурационные файлы, содержащие локальные настройки или ключи API, часто не должны попадать в репозиторий, чтобы избежать разглашения конфиденциальной информации.
3) Улучшение чистоты и структуры репозитория:
- Файл `.gitignore` помогает избежать загромождения репозитория неинтересующими файлами, что делает его более чистым и удобным для работы.
4) Работа в команде:
- Если команда разработчиков использует разные среды разработки или операционные системы, `.gitignore` позволяет каждому игнорировать файлы, которые могут быть специфичны для их среды.
5) Ускорение операций Git:
- Игнорирование больших или временных файлов позволяет уменьшить объем данных, с которыми работает Git, что может улучшить производительность.

</details>

<details><summary>Для чего нужна команда git diff?</summary><br>

Команда `git diff` в Git используется для просмотра различий между версиями файлов в рабочей директории и индексом (staging area), а также между индексом и последним коммитом.

</details>

<details><summary>Для чего нужна команда git blame?</summary><br>

Команда `git blame` в Git используется для определения, кто и когда внес изменения в каждую строку файла. Это может быть полезным, чтобы понять, кто ответственен за конкретные части кода или для анализа истории изменений.

Эта команда выводит информацию о каждой строке файла в следующем формате:

`<хеш коммита> <имя автора> <дата изменения> <содержимое строки>`

</details>

<details><summary>Для чего нужна команда git ls-files?</summary><br>

Команда `git ls-files` используется для отображения списка файлов, которые отслеживаются Git в текущем репозитории.

Команда `git ls-files` полезна, когда вы хотите увидеть список всех файлов, которые управляются Git и могли бы быть изменены, но ещё не были добавлены в индекс.

</details>

### Linux

<details><summary>Что такое Load Average?</summary><br>

Load Average (средняя загрузка) в операционных системах относится к метрике, показывающей среднюю нагрузку на систему за определенный период времени. Она измеряется в числах и представляет собой среднее количество процессов, ожидающих выполнения (в очереди) в течение заданного времени.

В Unix-подобных системах, таких как Linux, существуют три значения Load Average, которые обычно представлены в выводе команды uptime:

- 1 минута (1-minute Load Average): Средняя нагрузка за последнюю минуту.

- 5 минут (5-minute Load Average): Средняя нагрузка за последние пять минут.

- 15 минут (15-minute Load Average): Средняя нагрузка за последние пятнадцать минут.

Эти значения предоставляют информацию о текущей активности процессора. Если Load Average равно числу ядер процессора (например, 4 на четырехядерной системе), то система загружена на 100%. Если значение выше, то это означает, что есть процессы, ожидающие своей очереди на выполнение.

Когда Load Average резко возрастает и держится на высоком уровне длительное время, это может свидетельствовать о перегрузке сервера. Это может быть вызвано большим количеством активных процессов, что требует больше ресурсов CPU, памяти или дискового пространства.
</details>

<details><summary>Какова файловая структура в Linux (UNIX) системах, расположенных в /etc, /dev, /proc, /sys, /lib, /var ?</summary><br>

В Linux (и других UNIX-подобных) системах, существуют особые директории, каждая из которых имеет свою специальную роль в системе. Вот краткое описание файловой структуры для некоторых из них:

- /etc (Configuration Files): В этой директории хранятся конфигурационные файлы системы и установленных программ. Эти файлы часто содержат параметры и настройки, необходимые для правильной работы программ.
- /dev (Device Files): Здесь располагаются файлы-устройства, представляющие собой интерфейсы к устройствам в системе, таким как диски, порты и другие.
- /proc (Process Information): Эта виртуальная файловая система предоставляет информацию о запущенных процессах и ресурсах системы. Все данные представлены в виде файлов и каталогов.
- /sys (Sysfs Filesystem): Это также виртуальная файловая система, предоставляющая информацию о конфигурации и состоянии устройств в системе.
- /lib и /lib64 (Shared Libraries): Эти директории содержат динамические библиотеки, которые используются программами во время выполнения. Они предоставляют функции, которые могут быть использованы несколькими программами одновременно.
- /var (Variable Data): В этой директории хранятся данные, которые изменяются во время работы системы, такие как логи, временные файлы, кэши и другие.

- Эти директории имеют особое значение для работы операционной системы Linux и используются для различных аспектов её функционирования. Например, в /etc хранятся настройки, в /dev представлены устройства, а /proc и /sys предоставляют информацию о текущем состоянии системы.
</details>

<details><summary>Что такое скрытые файлы/каталоги? Как их просмотреть?</summary><br>

Скрытые файлы и каталоги в операционной системе Linux (и других UNIX-подобных системах) начинаются с точки в начале имени файла или каталога. Например, .bashrc или .config.

Они считаются скрытыми, потому что по умолчанию они не отображаются при просмотре содержимого каталога.

Чтобы просмотреть скрытые файлы и каталоги, используйте одну из следующих команд:

- Команда `ls -a` отобразит все файлы, включая скрытые.

- Команда `ls -A` отобразит все файлы, исключая ссылку на текущий и родительский каталоги (. и ..).

- Команда `ls -la` покажет детальную информацию о файлах, включая скрытые.

</details>

<details><summary>В чем разница между Ctrl+C и Ctrl+Z?</summary><br>

- Ctrl+C используется для прерывания (или завершения) выполнения текущей команды. Это действие приводит к остановке процесса с отправкой сигнала прерывания (`SIGINT`) этому процессу. В большинстве случаев, это приводит к тому, что команда завершает свою работу, а управление возвращается обратно к командной строке.

- Ctrl+Z используется для приостановки (паузы) текущего процесса. Он отправляет сигнал `SIGTSTP`, что означает, что процесс приостановлен и можно его возобновить позднее с помощью команды `fg` (foreground) или запустить в фоновом режиме с помощью команды `bg` (background).

Итак, основная разница между Ctrl+C и Ctrl+Z заключается в том, что Ctrl+C прерывает (и завершает) выполнение текущей команды, а Ctrl+Z приостанавливает текущий процесс и переводит его в фоновый режим.

</details>

<details><summary>Как убить процесс? Какие есть типы сигналов?</summary><br>

- Чтобы завершить (убить) процесс в командной строке Linux, используют команду `kill`. Вот примеры:

- Использование PID (Идентификатор процесса): `kill PID` где PID - это уникальный номер, присвоенный каждому процессу системой.

- Использование имени процесса: `pkill имя_процесса` эта команда завершит все процессы с указанным именем.

- Использование сигналов: `kill -сигнал PID`. Например, чтобы послать сигнал завершения (SIGTERM), используйте `kill -15 PID`

**Типы сигналов:**

- SIGHUP (1): Сигнал остановки процесса. Используется, когда процесс должен перезагрузиться.

- SIGINT (2): Сигнал прерывания. Обычно генерируется при нажатии Ctrl+C. Завершает выполнение процесса.

- SIGQUIT (3): Сигнал завершения. Генерируется при нажатии Ctrl+.

- SIGKILL (9): Сигнал немедленной остановки. Процесс завершается немедленно и не может перехватывать этот сигнал.

- SIGTERM (15): Сигнал завершения. Этот сигнал посылает запрос на завершение процесса, позволяя ему корректно завершить все текущие задачи перед закрытием.

- SIGSTOP (19): Сигнал остановки процесса. Приостанавливает процесс, который может быть потом возобновлен.

- SIGCONT (18): Сигнал продолжения. Используется для возобновления приостановленного процесса.

И это только часть списка. В Linux существует множество других сигналов с различными функциями. Вы можете узнать больше о них, выполнив команду `man 7 signal` в терминале.

</details>